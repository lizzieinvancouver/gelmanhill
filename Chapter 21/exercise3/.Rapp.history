length(unique(ars$as))
names(ars)
ars$arsenic
plot(ars$arsenic)
plot(arsenic)
names(ars)
unique(arsenic)
length(unique(arsenic))
length(unique(ars$as))
unique(ars$as)
print(wells_interaction.sf, pars = c("beta", "lp__"))
example(interaction.plot)
interaction.plot(dist100, arsenic, switc)
interaction.plot(arsenic, dist100, switc)
?cut
interaction.plot(cut(arsenic, 5), dist100, switc)
interaction.plot(dist100, cut(arsenic, 5), switc)
example(interaction.plot)
dose
ToothGrowth$dose
cut(arsenic, 4)
ars4 <- cut(arsenic, 4)
interaction.plot(dist100, ars4, switc)
example(interaction.plot)
ToothGrowth$supp
ToothGrowth$len
switc
interaction.plot(dist100, ars4, switc)
b <- colMeans(extract(wells_dae.sf, "beta")$beta)#
invlogit <- function(x) plogis(x)#
#
# for distance to nearest safe well#
#
hi <- 1#
lo <- 0#
delta <- invlogit(b[1] + b[2] * hi + b[3] * arsenic + b[4] * educ / 4) -#
         invlogit(b[1] + b[2] * lo + b[3] * arsenic + b[4] * educ / 4)#
print(mean(delta))#
#
# for arsenic
b <- colMeans(extract(wells_interactions.sf, "beta")$beta)
b
wells_interactions.sf
b <- colMeans(extract(wells_interaction.sf, "beta")$beta)
b
invlogit <- function(x) plogis(x)
hi <- 1#
lo <- 0
delta <- invlogit(b[1] + b[2] * hi + b[3] * arsenic + b[4] * educ / 4) -#
         invlogit(b[1] + b[2] * lo + b[3] * arsenic + b[4] * educ / 4)
inter
hi <- 1#
lo <- 0#
delta <- invlogit(b[1] + b[2] * hi + b[3] * arsenic + b[4] * arsenic*dist100) -#
         invlogit(b[1] + b[2] * lo + b[3] * arsenic + b[4] * arsenic*dist100)#
print(mean(delta))
delta <- invlogit(b[1] + b[2] * hi + b[3] * arsenic + b[4] * arsenic*dist100) -
hi <- 1.0#
lo <- 0.5#
ars.delta <- invlogit(b[1] + b[2] * dist100 + b[3] * hi + b[4] * arsenic*dist100) -#
         invlogit(b[1] + b[2] * dist100 + b[3] * lo + b[4] * arsenic*dist100)
hi <- 1.0#
lo <- 0.5
ars.delta <- invlogit(b[1] + b[2] * dist100 + b[3] * hi + b[4] * arsenic*dist100) -#
         invlogit(b[1] + b[2] * dist100 + b[3] * lo + b[4] * arsenic*dist100)
ars.delta
as.delta <- invlogit(b[1] + b[2] * dist100 + b[3] * hi + b[4] * arsenic*dist100) -
as.delta
as.delta <- invlogit(b[1] + b[2] * dist100 + b[3] * hi + b[4] * arsenic*dist100) -
invlogit(b[1] + b[2] * dist100 + b[3] * lo + b[4] * arsenic*dist100)
as.delta
dist.delta
dist.delta <- invlogit(b[1] + b[2] * hi + b[3] * arsenic + b[4] * arsenic*dist100) -#
         invlogit(b[1] + b[2] * lo + b[3] * arsenic + b[4] * arsenic*dist100)
dist.delta
mean(dist.delta)
dist.m <- mean(dist.delta)
dist.se <- sd(dist.delta)/sqrt(length(dist.delta)-1)
dist.se
as.se <- sd(as.delta)/sqrt(length(as.delta)-1)
as.m <- mean(as.delta)
plot(c(dist.m, as.m))
xlim = c(-2, 4))
plot(c(dist.m, as.m), pch = 16, #
	xlim = c(-2, 4))
abline(h=0, lty=3)
plot(c(dist.m, as.m), pch = 16, #
	xlim = c(-2, 4))#
abline(v=0, lty=3)
arrows(dist.m-dist.se, dist.m, dist.m+dist.se, dist.m, length = 0)
arrows(dist.m-dist.se, dist.m, dist.m+dist.se, dist.m, length = 0.2)
dist.m+dist.se
arrows(dist.m-dist.se, dist.m, dist.m+dist.se, dist.m)
dist.m
dist.m+dist.se
plot(c(dist.m, as.m), 1:2, pch = 16,
xlim = c(-2, 4),
yaxt= "n")
abline(v=0, lty=3)#
arrows(dist.m-dist.se, dist.m, dist.m+dist.se, dist.m)
arrows(dist.m-dist.se, dist.m, dist.m+dist.se, dist.m)
plot(c(dist.m, as.m), 1:2, pch = 16, #
	xlim = c(-1, 1),#
	yaxt= "n")#
abline(v=0, lty=3)#
arrows(dist.m-dist.se, dist.m, dist.m+dist.se, dist.m)
arrows(dist.m-dist.se, dist.m, dist.m+dist.se, dist.m)
arrows(as.m-as.se, as.m, as.m+as.se, as.m)
lines(dist.m-dist.se, dist.m+dist.se)
dist.m-dist.se
dist.m+dist.se
dist.m
dist.delta
arrows(as.m-as.se, as.m, as.m+as.se, as.m)
hi <- 1#
lo <- 0#
dist.delta <- invlogit(b[1] + b[2] * hi + b[3] * arsenic + b[4] * arsenic*dist100) -#
         invlogit(b[1] + b[2] * lo + b[3] * arsenic + b[4] * arsenic*dist100)
wells_interaction.sf
extract(wells_interaction.sf, "beta")
extract(wells_interaction.sf, "beta")$beta
colMeans(extract(wells_interaction.sf, "beta")$beta)
wells_interaction.sf
extract(wells_interaction.sf, "beta")
b <- colMeans(extract(wells_interaction.sf, "beta")$beta)
b
dist.delta <- invlogit(b[1] + b[2] * hi + b[3] * arsenic + b[4] * arsenic*dist100) -#
         invlogit(b[1] + b[2] * lo + b[3] * arsenic + b[4] * arsenic*dist100)
dist.delta
arsenic
arsenic*dist100
invlogit(b[1] + b[2] * hi + b[3] * arsenic + b[4] * arsenic*dist100) -#
         invlogit(b[1] + b[2] * lo + b[3] * arsenic + b[4] * arsenic*dist100)
b[1]
b[2]
arsenic
dist.delta <- invlogit(b[1] + b[2] * hi + b[3] * arsenic + b[4] * arsenic*hi) -#
         invlogit(b[1] + b[2] * lo + b[3] * arsenic + b[4] * arsenic*lo)
dist.delta
hi <- 1.0#
lo <- 0.5#
as.delta <- invlogit(b[1] + b[2] * dist100 + b[3] * hi + b[4] * hi*dist100) -#
         invlogit(b[1] + b[2] * dist100 + b[3] * lo + b[4] * lo*dist100)
as.delta
hi <- 1#
lo <- 0#
dist.delta <- invlogit(b[1] + b[2] * hi + b[3] * arsenic + b[4] * arsenic*hi) -#
         invlogit(b[1] + b[2] * lo + b[3] * arsenic + b[4] * arsenic*lo)#
#
# for arsenic #
#
hi <- 1.0#
lo <- 0.5#
as.delta <- invlogit(b[1] + b[2] * dist100 + b[3] * hi + b[4] * hi*dist100) -#
         invlogit(b[1] + b[2] * dist100 + b[3] * lo + b[4] * lo*dist100)
dist.m <- mean(dist.delta)#
dist.se <- sd(dist.delta)/sqrt(length(dist.delta)-1)
as.m <- mean(as.delta)#
as.se <- sd(as.delta)/sqrt(length(as.delta)-1)
plot(c(dist.m, as.m), 1:2, pch = 16, #
	xlim = c(-1, 1),#
	yaxt= "n")#
abline(v=0, lty=3)#
arrows(dist.m-dist.se, dist.m, dist.m+dist.se, dist.m)#
arrows(as.m-as.se, as.m, as.m+as.se, as.m)
dist.m
as.m
library(rstan)#
library(foreign)#
library(arm)
setwd("~/Documents/git/gelmanhill/")
# Getting data in and following Chapter 17 example#
srrs2 <- read.table("ARM_Data/radon/srrs2.dat", header=T, sep=",")#
mn <- srrs2$state=="MN"#
radon <- srrs2$activity[mn]#
log.radon <- log (ifelse (radon==0, .1, radon))#
floor <- srrs2$floor[mn]       # 0 for basement, 1 for first floor#
n <- length(radon)#
y <- log.radon#
x <- floor#
#
# get county index variable#
county.name <- as.vector(srrs2$county[mn])#
uniq <- unique(county.name)#
J <- length(uniq)#
county <- rep (NA, J)#
for (i in 1:J){#
  county[county.name==uniq[i]] <- i#
}#
#
# no predictors#
ybarbar = mean(y)
sample.size <- as.vector (table (county))#
sample.size.jittered <- sample.size*exp (runif (J, -.1, .1))#
cty.mns = tapply(y,county,mean)#
cty.vars = tapply(y,county,var)#
cty.sds = mean(sqrt(cty.vars[!is.na(cty.vars)]))/sqrt(sample.size)#
cty.sds.sep = sqrt(tapply(y,county,var)/sample.size)
# radon varying intercept and slope model#
dataList.1 <- list(N=length(y), y=y, county=county, J=J, x=x)#
radon_vary_inter_slope.sf1 <- stan(file='Chapter 17/17.1_radon_vary_inter_slope.stan', data=dataList.1,#
                                   iter=1000, chains=4)#
print(radon_vary_inter_slope.sf1)
print(radon_vary_inter_slope.sf1)
est <- extract(radon_vary_inter_slope.sf1, permuted = T)#
#
# Means and s.e. of county level intercepts (show only first 100 rows here)#
#
summary(radon_vary_inter_slope.sf1)$summary[1:100,]
ml1 <- lmer(y ~ x + (1 | county))#
display(ml1)#
summary(ml1)
oly <- read.csv("Chapter 21/olympicslong.csv")
# radon varying intercept and slope model#
dataList.1 <- list(N=length(y), y=y, county=county, J=J, x=x)#
radon_vary_inter_slope.sf2 <- stan(file='Chapter 21/17.1_radon_vary_inter_slope_finite.stan', data=dataList.1,#
                                   iter=1000, chains=4)
print(radon_vary_inter_slope.sf2)#
#
summary(radon_vary_inter_slope.sf2)$summary[1:100,]
setwd("~/Documents/H/gelmanhill/Chapter 21")#
source("wells.data.R", echo = TRUE)
data.list.1 <- list(N=N, switc=switc, dist=dist, arsenic=arsenic)#
wells_interaction.sf <- stan(file='wells_interaction.stan', data=data.list.1,#
                             iter=1000, chains=4)#
print(wells_interaction.sf, pars = c("beta", "lp__"))
setwd("~/Documents/git/gelmanhill/Chapter 21")
source("wells.data.R", echo = TRUE)
head(arsenic)
length(arsenic)
village = sample(1:20, length(arsenic), replace = T)
village
data.list.1 <- list(N=N, switc=switc, dist=dist, arsenic=arsenic, village = village)
wells_interaction.sf <- stan(file='wells_interaction_village.stan', data=data.list.1,#
                             iter=1000, chains=4)#
print(wells_interaction.sf, pars = c("beta", "lp__"))
data.list.1 <- list(N=N, switc=switc, dist=dist, arsenic=arsenic, village = village, J = length(unique(village)))
data.list.1
data.list.1 <- list(N=N, switc=switc, dist=dist, arsenic=arsenic, village = village, J = length(unique(village)))#
wells_interaction.sf <- stan(file='wells_interaction_village.stan', data=data.list.1,#
                             iter=1000, chains=4)#
print(wells_interaction.sf, pars = c("beta", "lp__"))
data.list.1 <- list(N=N, switc=switc, dist=dist, arsenic=arsenic, village = village, J = length(unique(village)))#
wells_interaction.sf <- stan(file='wells_interaction_village.stan', data=data.list.1,#
                             iter=1000, chains=4)
data.list.1 <- list(N=N, switc=switc, dist=dist, arsenic=arsenic, village = village, J = length(unique(village)))#
wells_interaction.sf <- stan(file='wells_interaction_village.stan', data=data.list.1,#
                             iter=1000, chains=4)
wells_interaction.sf <- stan(file='wells_interaction_village.stan', data=data.list.1,#
                             iter=1000, chains=4)
wells_interaction.sf <- stan(file='wells_interaction_village.stan', data=data.list.1,#
                             iter=1000, chains=4)
wells_interaction.sf <- stan(file='wells_interaction_village.stan', data=data.list.1,#
                             iter=1000, chains=4)
### 7 September 2015 ####
### Started by Lizzie ####
#
## Working off 21.6_SummarizingtheAmmountofPartialPooling.R from example-models/ARM repo on github ###
#
# setwd("~/Documents/git/teaching/gelmanhill/Chapter 21/exercise3")#
#
library(rstan)#
library(ggplot2)#
#
srrs2 <- read.table ("..//..//ARM_Data/radon/srrs2.dat", header=TRUE, sep=",")#
mn <- srrs2$state=="MN"#
radon <- srrs2$activity[mn]#
log.radon <- log (ifelse (radon==0, .1, radon))#
floor <- srrs2$floor[mn]       # 0 for basement, 1 for first floor#
n <- length(radon)#
y <- log.radon#
x <- floor
mn <- srrs2$state=="MN"
radon <- srrs2$activity[mn]#
log.radon <- log (ifelse (radon==0, .1, radon))#
floor <- srrs2$floor[mn]       # 0 for basement, 1 for first floor#
n <- length(radon)#
y <- log.radon#
x <- floor
county.name <- as.vector(srrs2$county[mn])#
uniq <- unique(county.name)#
J <- length(uniq)#
county <- rep (NA, J)#
for (i in 1:J){#
  county[county.name==uniq[i]] <- i#
}#
#
# no predictors#
ybarbar = mean(y)
sample.size <- as.vector (table (county))#
sample.size.jittered <- sample.size*exp (runif (J, -.1, .1))#
cty.mns = tapply(y,county,mean)#
cty.vars = tapply(y,county,var)#
cty.sds = mean(sqrt(cty.vars[!is.na(cty.vars)]))/sqrt(sample.size)#
cty.sds.sep = sqrt(tapply(y,county,var)/sample.size)
## Get the county-level predictor#
srrs2.fips <- srrs2$stfips*1000 + srrs2$cntyfips#
cty <- read.table ("..//..//ARM_Data/radon/cty.dat", header=T, sep=",")#
usa.fips <- 1000*cty[,"stfips"] + cty[,"ctfips"]#
usa.rows <- match (unique(srrs2.fips[mn]), usa.fips)#
uranium <- cty[usa.rows,"Uppm"]#
u <- log (uranium)#
u.full <- u[county]
usa.fips <- 1000*cty[,"stfips"] + cty[,"ctfips"]
cty <- read.table ("..//..//ARM_Data/radon/cty.dat", header=T, sep=",")
setwd("~/Documents/git/gelmanhill/Chapter 21/exercise3") # DF
library(rstan)#
library(ggplot2)#
#
srrs2 <- read.table ("..//..//ARM_Data/radon/srrs2.dat", header=TRUE, sep=",")#
mn <- srrs2$state=="MN"#
radon <- srrs2$activity[mn]#
log.radon <- log (ifelse (radon==0, .1, radon))#
floor <- srrs2$floor[mn]       # 0 for basement, 1 for first floor#
n <- length(radon)#
y <- log.radon#
x <- floor#
#
# get county index variable#
county.name <- as.vector(srrs2$county[mn])#
uniq <- unique(county.name)#
J <- length(uniq)#
county <- rep (NA, J)#
for (i in 1:J){#
  county[county.name==uniq[i]] <- i#
}#
#
# no predictors#
ybarbar = mean(y)#
#
sample.size <- as.vector (table (county))#
sample.size.jittered <- sample.size*exp (runif (J, -.1, .1))#
cty.mns = tapply(y,county,mean)#
cty.vars = tapply(y,county,var)#
cty.sds = mean(sqrt(cty.vars[!is.na(cty.vars)]))/sqrt(sample.size)#
cty.sds.sep = sqrt(tapply(y,county,var)/sample.size)#
#
## Get the county-level predictor#
srrs2.fips <- srrs2$stfips*1000 + srrs2$cntyfips#
cty <- read.table ("..//..//ARM_Data/radon/cty.dat", header=T, sep=",")#
usa.fips <- 1000*cty[,"stfips"] + cty[,"ctfips"]#
usa.rows <- match (unique(srrs2.fips[mn]), usa.fips)#
uranium <- cty[usa.rows,"Uppm"]#
u <- log (uranium)
u.full <- u[county]
## Fit the model#
# radon (our y variable) predicted by a linear model with x=floor and county as a modeled parameter, u=uraniam#
dataList.1 <- list(N=n,J=85,y=y,u=u,x=x,county=county)#
radon_vary_intercept_a.sf1 <- stan(file='radon_vary_intercept_a.stan',#
                                   data=dataList.1, iter=1000, chains=4)#
print(radon_vary_intercept_a.sf1,pars = c("a","b","sigma_y", "lp__"))#
post <- extract(radon_vary_intercept_a.sf1)#
e.a <- colMeans(post$e_a)#
omega <- (sd(e.a)/mean(post$sigma_a))^2#
omega <- pmin (omega, 1)
dataList.1 <- list(N=n,J=85,y=y,u=u,x=x,county=county)
radon_vary_intercept_a.sf1 <- stan(file='radon_vary_intercept_a.stan',#
                                   data=dataList.1, iter=1000, chains=4)
## Fit the model with varying slope #
dataList.2 <- list(N=n,J=85,y=y,u=u,x=x,county=county)#
radonmod2 <- stan(file='radon_vary_interceptslope_a.stan',#
                                   data=dataList.2, iter=1000, chains=4)
qq<-summary(radonmod2)
class(radonmod2) # gives the overall summary and then each of the four chains (I think)
qq[[1]][,6]
a.meanfromstan <- as.vector(qq[[1]][,1])[1:85]#
b.meanfromstan <- as.vector(qq[[1]][,1])[86:170]#
a.50fromstan <- as.vector(qq[[1]][,6])[1:85]#
b.50fromstan <- as.vector(qq[[1]][,6])[86:170]
head(qq)
str(qq)
qq$summary
head(qq$summary)
rownames(qq$summary)
grep("a", rownames(qq$summary))
qq$summary[grep("a", rownames(qq$summary)),]
qq$summary[grep("$a", rownames(qq$summary)),]
qq$summary[grep("+a", rownames(qq$summary)),]
qq$summary[grep("^a", rownames(qq$summary)),]
qq$summary[grep("^a[", rownames(qq$summary)),]
qq$summary[grep("^a$", rownames(qq$summary)),]
qq$summary[grep("^a", rownames(qq$summary)),]
qq$summary[grep("^a[", rownames(qq$summary)),]
qq$summary[grep("^a\\[", rownames(qq$summary)),]
qq$summary[grep("^a\\[", rownames(qq$summary)),1]
a.meanfromstan <- as.vector(qq[[1]][,1])[1:85]
a.meanfromstan
# alt: vector(qq$summary[grep("^a\\[", rownames(qq$summary)),1])
vector(qq$summary[grep("^a\\[", rownames(qq$summary)),1])
as.vector(qq$summary[grep("^a\\[", rownames(qq$summary)),1])
as.numeric(qq$summary[grep("^a\\[", rownames(qq$summary)),1])
b.meanfromstan <- as.vector(qq[[1]][,1])[86:170]
as.numeric(qq$summary[grep("^b\\[", rownames(qq$summary)),1]) # or as.vector. use ^b\\[ for betas
mean(a.meanfromstan) # 1.47#
mean(b.meanfromstan) # -1.64^-03#
mean(a.50fromstan) # 1.47#
mean(b.50fromstan) # -4.85^-4
post2 <- extract(radonmod2)
attach(post2)
finite.slopes <- rep(NA, 1000)
length(post2)
dim(post2)
post2
str(post2)
county10 <- county[which(county<11)]
x10 <- x[which(county<11)]#
y10 <- y[which(county<11)]#
u10 <- u[1:10]
dataList.3 <- list(N=length(county10),J=10,y=y10,u=u10,x=x10,county=county10)
radonmod3 <- stan(file='radon_vary_interceptslope_a.stan',#
                                   data=dataList.3, iter=1000, chains=4)
pp<-summary(radonmod3)
class(radonmod3)
pp[[1]][,6]
str(pp)
str(pp$summary)
head(pp$summary)
(pp$summary)
a.meanfromstan <- as.vector(pp[[1]][,1])[1:10]#
b.meanfromstan <- as.vector(pp[[1]][,1])[11:20]#
a.50fromstan <- as.vector(pp[[1]][,6])[1:10]#
b.50fromstan <- as.vector(pp[[1]][,6])[11:20]
mean(a.meanfromstan) # 1.40#
mean(b.meanfromstan) # -0.031#
mean(a.50fromstan) # 1.42#
mean(b.50fromstan) # -0.038
wells_interaction.sf <- stan(file='wells_interaction_village.stan', data=data.list.1,#
                             iter=1000, chains=4)
setwd("~/Documents/git/gelmanhill/Chapter 21")#
source("wells.data.R", echo = TRUE)#
#
# background on p 87. Safe: below .5 mg / L arsenic. Distance to nearest safe well a strong predictor; high distance, less likely to swtich.#
#
# Adding a fake 'village' variable for purpose of the exercise#
#
village = sample(1:20, length(arsenic), replace = T)#
#
data.list.1 <- list(N=N, switc=switc, dist=dist, arsenic=arsenic, village = village, J = length(unique(village)))#
wells_interaction.sf <- stan(file='wells_interaction_village.stan', data=data.list.1,
iter=1000, chains=4)
data.list.1 <- list(N=N, switc=switc, dist=dist, arsenic=arsenic, village = village, J = length(unique(village)))
data.list.1 <- list(N=N, switc=switc, dist=dist, arsenic=arsenic, village = village, n_vill = length(unique(village)))
wells_interaction.sf <- stan(file='wells_interaction_village.stan', data=data.list.1,#
                             iter=1000, chains=4)
village
wells_interaction.sf <- stan(file='wells_interaction_village_debug.stan', data=data.list.1,#
                             iter=1000, chains=4)
setwd("~/Documents/git/gelmanhill/Chapter 21")
wells_interaction.sf <- stan(file='wells_interaction_village_debug.stan', data=data.list.1,#
                             iter=1000, chains=4)
dir()
wells_interaction.sf <- stan(file='wells_interaction_village2_debug.stan', data=data.list.1,#
                             iter=1000, chains=4)
wells_interaction.sf <- stan(file='wells_interaction_village2_debug.stan', data=data.list.1,#
                             iter=1000, chains=4)
wells_interaction.sf <- stan(file='wells_interaction_village2_debug.stan', data=data.list.1,#
                             iter=1000, chains=4)
wells_interaction.sf <- stan(file='wells_interaction_village2_debug.stan', data=data.list.1,#
                             iter=1000, chains=4)
wells_interaction.sf <- stan(file='wells_interaction_village2_debug.stan', data=data.list.1,#
                             iter=1000, chains=4)
wells_interaction.sf <- stan(file='wells_interaction_village2_debug.stan', data=data.list.1,#
                             iter=1000, chains=4)
wells_interaction.sf <- stan(file='wells_interaction_village2_debug.stan', data=data.list.1,#
                             iter=1000, chains=4)
wells_interaction.sf <- stan(file='wells_interaction_village2_debug.stan', data=data.list.1,#
                             iter=1000, chains=4)
oly <- read.csv("Chapter 21/olympicslong.csv")#
#
perf.oly <- oly[oly$criterion == "Performance",]#
#
mo <- lmer(rating ~ (1 | judge) + (1 | pair), data = oly[oly$criterion == "Performance",])
mo
head(oly)
## Working off 21.6_SummarizingtheAmmountofPartialPooling.R from example-models/ARM repo on github ###
#
# setwd("~/Documents/git/teaching/gelmanhill/Chapter 21/exercise3")#
# setwd("~/Documents/git/gelmanhill/Chapter 21/exercise3") # DF#
#
library(rstan)#
library(ggplot2)
srrs2 <- read.table ("..//..//ARM_Data/radon/srrs2.dat", header=TRUE, sep=",")#
mn <- srrs2$state=="MN"#
radon <- srrs2$activity[mn]#
log.radon <- log (ifelse (radon==0, .1, radon))#
floor <- srrs2$floor[mn]       # 0 for basement, 1 for first floor#
n <- length(radon)#
y <- log.radon#
x <- floor
setwd("~/Documents/git/gelmanhill/Chapter 21/exercise3") # DF#
#
library(rstan)#
library(ggplot2)#
#
srrs2 <- read.table ("..//..//ARM_Data/radon/srrs2.dat", header=TRUE, sep=",")#
mn <- srrs2$state=="MN"#
radon <- srrs2$activity[mn]#
log.radon <- log (ifelse (radon==0, .1, radon))#
floor <- srrs2$floor[mn]       # 0 for basement, 1 for first floor#
n <- length(radon)#
y <- log.radon#
x <- floor
county.name <- as.vector(srrs2$county[mn])#
uniq <- unique(county.name)#
J <- length(uniq)#
county <- rep (NA, J)#
for (i in 1:J){#
  county[county.name==uniq[i]] <- i#
}
# get county index variable#
county.name <- as.vector(srrs2$county[mn])#
uniq <- unique(county.name)#
J <- length(uniq)#
county <- rep (NA, J)#
for (i in 1:J){#
  county[county.name==uniq[i]] <- i#
}#
#
# no predictors#
ybarbar = mean(y)#
#
sample.size <- as.vector (table (county))#
sample.size.jittered <- sample.size*exp (runif (J, -.1, .1))#
cty.mns = tapply(y,county,mean)#
cty.vars = tapply(y,county,var)#
cty.sds = mean(sqrt(cty.vars[!is.na(cty.vars)]))/sqrt(sample.size)#
cty.sds.sep = sqrt(tapply(y,county,var)/sample.size)
qq<-summary(radonmod2)
print(radonmod2,pars = c("a","b","sigma_y", "lp__"))
qq<-summary(radonmod2)
qq$summary
a.meanfromstan <- as.vector(qq[[1]][,1])[1:85]#
# alt: #
as.numeric(qq$summary[grep("^a\\[", rownames(qq$summary)),1]) # or as.vector. use ^b\\[ for betas#
b.meanfromstan <- as.vector(qq[[1]][,1])[86:170] # these are a_hat, not b...#
as.numeric(qq$summary[grep("^b\\[", rownames(qq$summary)),1]) #
a.50fromstan <- as.vector(qq[[1]][,6])[1:85]#
as.numeric(qq$summary[grep("^a\\[", rownames(qq$summary)),6])#
b.50fromstan <- as.vector(qq[[1]][,6])[86:170]#
as.numeric(qq$summary[grep("^b\\[", rownames(qq$summary)),6])
mean(a.meanfromstan) # 1.47#
mean(b.meanfromstan) # -1.64^-03#
mean(a.50fromstan) # 1.47#
mean(b.50fromstan) # -4.85^-4#
# Why is 50% interval so different from mean here but not below?
head(qq$summary)
mean(a.meanfromstan) # 1.47
mean(a.50fromstan) # 1.47
mean(b.meanfromstan) # -1.64^-03
mean(b.50fromstan) # -4.85^-4
mean(b.meanfromstan) # -1.64^-03
mean(b.50fromstan) # -4.85^-4
post2 <- extract(radonmod2)
str(radonmod2)
head(str(radonmod2))
finite.slopes <- rep(NA, 1000)
for (J in 1:1000){#
    finite.pop <- lm (a[J,] ~ b)#
    finite.slopes[J] <- coef(finite.pop)["b"]#
}
str(post2)
head(qq$summary)
